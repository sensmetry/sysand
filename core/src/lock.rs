// SPDX-FileCopyrightText: Â© 2025 Sysand contributors <opensource@sensmetry.com>
// SPDX-License-Identifier: MIT OR Apache-2.0

use std::fmt::Display;

use serde::Deserialize;
use thiserror::Error;
use toml_edit::{
    Array, ArrayOfTables, DocumentMut, Formatted, InlineTable, Item, Table, Value, value,
};

use crate::{env::ReadEnvironment, project::ProjectRead};

pub const CURRENT_LOCK_VERSION: &str = "0.1";
pub const LOCKFILE_PREFIX: &str = "# This file is automatically generated by Sysand and is not intended to be edited manually.\n\n";

#[derive(Clone, PartialEq, Deserialize, Debug)]
pub struct Lock {
    pub lock_version: String,
    #[serde(rename = "project", skip_serializing_if = "Vec::is_empty", default)]
    pub projects: Vec<Project>,
}

impl Default for Lock {
    fn default() -> Self {
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![],
        }
    }
}

impl Display for Lock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}{}", LOCKFILE_PREFIX, self.to_toml())
    }
}

#[derive(Error, Debug)]
pub enum LockResolutionEror<EnvironmentError> {
    #[error("{0}")]
    EnvironmentError(EnvironmentError),
    #[error("missing projects: {0:?}")]
    MissingProjects(Vec<Project>),
}

impl Lock {
    pub fn resolve_projects<Env: ReadEnvironment>(
        &self,
        env: &Env,
    ) -> Result<
        Vec<<Env as ReadEnvironment>::InterchangeProjectRead>,
        LockResolutionEror<Env::ReadError>,
    > {
        let mut missing = vec![];
        let mut found = vec![];

        for project in &self.projects {
            let checksum = &project.checksum;

            let mut resolved_project = None;

            'outer: for iri in &project.iris {
                for candidate_project in env
                    .candidate_projects(iri)
                    .map_err(LockResolutionEror::EnvironmentError)?
                {
                    if let Ok(Some(candidate_checksum)) = candidate_project.checksum_canonical_hex()
                    {
                        if candidate_checksum == *checksum {
                            resolved_project = Some(candidate_project);
                            break 'outer;
                        }
                    }
                }
            }

            if let Some(success) = resolved_project {
                found.push(success);
            } else {
                missing.push(project.clone());
            }
        }

        if !missing.is_empty() {
            return Err(LockResolutionEror::MissingProjects(missing));
        }

        Ok(found)
    }

    pub fn to_toml(&self) -> DocumentMut {
        let mut doc = DocumentMut::new();
        doc.insert("lock_version", value(Value::from(&self.lock_version)));

        let mut projects = ArrayOfTables::new();
        for project in &self.projects {
            projects.push(project.to_toml());
        }
        doc.insert("project", Item::ArrayOfTables(projects));

        doc
    }
}

#[derive(Clone, PartialEq, Deserialize, Debug)]
pub struct Project {
    pub name: String,
    pub version: String,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub exports: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub iris: Vec<String>,
    pub checksum: String,
    #[serde(skip_serializing_if = "Option::is_none", default)]
    pub specification: Option<String>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub sources: Vec<Source>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub usages: Vec<Usage>,
}

impl Project {
    pub fn to_toml(&self) -> Table {
        let mut table = Table::new();
        table.insert("name", value(&self.name));
        table.insert("version", value(&self.version));
        let exports = multiline_list(self.exports.iter().map(Value::from));
        if !exports.is_empty() {
            table.insert("exports", value(exports));
        }
        let iris = multiline_list(self.iris.iter().map(Value::from));
        if !iris.is_empty() {
            table.insert("iris", value(iris));
        }
        table.insert("checksum", value(&self.checksum));
        if let Some(specification) = &self.specification {
            table.insert("specification", value(specification));
        }
        let sources = multiline_list(self.sources.iter().map(|s| s.to_toml()));
        if !sources.is_empty() {
            table.insert("sources", value(sources));
        }
        let usages = multiline_list(self.usages.iter().map(|u| u.to_toml()));
        if !usages.is_empty() {
            table.insert("usages", value(usages));
        }
        table
    }
}

#[derive(Clone, PartialEq, Deserialize, Debug)]
#[serde(untagged)]
pub enum Source {
    Editable {
        editable: String,
    },
    LocalSrc {
        src_path: String,
    },
    LocalKpar {
        kpar_path: String,
    },
    Registry {
        registry: String,
    },
    RemoteKpar {
        remote_kpar: String,
        remote_kpar_size: Option<u64>,
    },
    RemoteSrc {
        remote_src: String,
    },
    RemoteGit {
        remote_git: String,
    },
    RemoteApi {
        remote_api: String,
    },
}

impl Source {
    pub fn to_toml(&self) -> InlineTable {
        let mut table = InlineTable::new();
        match self {
            Source::Editable { editable } => {
                table.insert("editable", Value::from(editable));
            }
            Source::LocalKpar { kpar_path } => {
                table.insert("kpar_path", Value::from(kpar_path));
            }
            Source::LocalSrc { src_path } => {
                table.insert("src_path", Value::from(src_path));
            }
            Source::Registry { registry } => {
                table.insert("registry", Value::from(registry));
            }
            Source::RemoteApi { remote_api } => {
                table.insert("remote_api", Value::from(remote_api));
            }
            Source::RemoteGit { remote_git } => {
                table.insert("remote_git", Value::from(remote_git));
            }
            Source::RemoteKpar {
                remote_kpar,
                remote_kpar_size,
            } => {
                table.insert("remote_kpar", Value::from(remote_kpar));
                if let Some(remote_kpar_size) = remote_kpar_size {
                    let size = i64::try_from(*remote_kpar_size).unwrap();
                    table.insert("remote_kpar_size", Value::Integer(Formatted::new(size)));
                }
            }
            Source::RemoteSrc { remote_src } => {
                table.insert("remote_src", Value::from(remote_src));
            }
        }
        table
    }
}

#[derive(Clone, PartialEq, Deserialize, Debug)]
pub struct Usage {
    pub resource: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_constraint: Option<String>,
}

impl Usage {
    pub fn to_toml(&self) -> InlineTable {
        let mut table = InlineTable::new();
        table.insert("resource", Value::from(&self.resource));
        if let Some(version_constraint) = &self.version_constraint {
            table.insert("version_constraint", Value::from(version_constraint));
        }
        table
    }
}

impl From<crate::model::InterchangeProjectUsageRaw> for Usage {
    fn from(value: crate::model::InterchangeProjectUsageRaw) -> Usage {
        Usage {
            resource: value.resource,
            version_constraint: value.version_constraint,
        }
    }
}

impl From<crate::model::InterchangeProjectUsage> for Usage {
    fn from(value: crate::model::InterchangeProjectUsage) -> Usage {
        Usage {
            resource: value.resource.to_string(),
            version_constraint: value.version_constraint.map(|vr| vr.to_string()),
        }
    }
}

fn multiline_list(elements: impl Iterator<Item = impl Into<Value>>) -> Array {
    let mut array: Array = elements
        .map(|item| {
            let mut value = item.into();
            value.decor_mut().set_prefix("\n    ");
            value
        })
        .collect();
    array.set_trailing_comma(true);
    array.set_trailing("\n");
    array
}

#[cfg(test)]
mod tests {
    use std::fmt::Display;

    use crate::lock::{CURRENT_LOCK_VERSION, LOCKFILE_PREFIX, Lock, Project, Source, Usage};

    fn test_to_toml<S: Display>(projects: Vec<Project>, toml: S) {
        let lockfile = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects,
        };
        let expected = format!(
            "{}lock_version = \"{}\"\n{}",
            LOCKFILE_PREFIX, CURRENT_LOCK_VERSION, toml
        );
        assert_eq!(lockfile.to_string(), expected.to_string());
    }

    #[test]
    fn minimal_to_toml() {
        test_to_toml(
            vec![Project {
                name: "Minimal".to_string(),
                version: "0.0.1".to_string(),
                exports: vec![],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![],
            }],
            r#"
[[project]]
name = "Minimal"
version = "0.0.1"
checksum = "00"
"#,
        );
    }

    #[test]
    fn one_export_to_toml() {
        test_to_toml(
            vec![Project {
                name: "One Package".to_string(),
                version: "0.1.1".to_string(),
                exports: vec!["PackageName".to_string()],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![],
            }],
            r#"
[[project]]
name = "One Package"
version = "0.1.1"
exports = [
    "PackageName",
]
checksum = "00"
"#,
        );
    }

    #[test]
    fn many_exports_to_toml() {
        test_to_toml(
            vec![Project {
                name: "Three Packages".to_string(),
                version: "0.1.3".to_string(),
                exports: vec![
                    "Package1".to_string(),
                    "Package2".to_string(),
                    "Package3".to_string(),
                ],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![],
            }],
            r#"
[[project]]
name = "Three Packages"
version = "0.1.3"
exports = [
    "Package1",
    "Package2",
    "Package3",
]
checksum = "00"
"#,
        );
    }

    #[test]
    fn one_iri_to_toml() {
        test_to_toml(
            vec![Project {
                name: "One IRI".to_string(),
                version: "0.2.1".to_string(),
                exports: vec![],
                iris: vec!["urn:kpar:example".to_string()],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![],
            }],
            r#"
[[project]]
name = "One IRI"
version = "0.2.1"
iris = [
    "urn:kpar:example",
]
checksum = "00"
"#,
        );
    }

    #[test]
    fn many_iris_to_toml() {
        test_to_toml(
            vec![Project {
                name: "Three IRI:s".to_string(),
                version: "0.2.3".to_string(),
                exports: vec![],
                iris: vec![
                    "urn:kpar:example".to_string(),
                    "ftp://www.example.com".to_string(),
                    "http://www.example.com".to_string(),
                ],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![],
            }],
            r#"
[[project]]
name = "Three IRI:s"
version = "0.2.3"
iris = [
    "urn:kpar:example",
    "ftp://www.example.com",
    "http://www.example.com",
]
checksum = "00"
"#,
        );
    }

    #[test]
    fn some_specification_to_toml() {
        test_to_toml(
            vec![Project {
                name: "Some specification".to_string(),
                version: "0.3.0".to_string(),
                exports: vec![],
                iris: vec![],
                checksum: "00".to_string(),
                specification: Some("example".to_string()),
                sources: vec![],
                usages: vec![],
            }],
            r#"
[[project]]
name = "Some specification"
version = "0.3.0"
checksum = "00"
specification = "example"
"#,
        );
    }

    #[test]
    fn ome_source_to_toml() {
        test_to_toml(
            vec![Project {
                name: "One source".to_string(),
                version: "0.4.1".to_string(),
                exports: vec![],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![Source::Editable {
                    editable: ".".to_string(),
                }],
                usages: vec![],
            }],
            r#"
[[project]]
name = "One source"
version = "0.4.1"
checksum = "00"
sources = [
    { editable = "." },
]
"#,
        );
    }

    #[test]
    fn many_sources_to_toml() {
        test_to_toml(
            vec![Project {
                name: "Seven sources".to_string(),
                version: "0.4.7".to_string(),
                exports: vec![],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![
                    Source::LocalKpar {
                        kpar_path: "example.kpar".to_string(),
                    },
                    Source::LocalSrc {
                        src_path: "example/path".to_string(),
                    },
                    Source::Registry {
                        registry: "www.example.com".to_string(),
                    },
                    Source::RemoteKpar {
                        remote_kpar: "www.example.com/remote.kpar".to_string(),
                        remote_kpar_size: Some(64),
                    },
                    Source::RemoteSrc {
                        remote_src: "www.example.com/remote".to_string(),
                    },
                    Source::RemoteGit {
                        remote_git: "github.com/example/remote.git".to_string(),
                    },
                    Source::RemoteApi {
                        remote_api: "www.example.com/api".to_string(),
                    },
                ],
                usages: vec![],
            }],
            r#"
[[project]]
name = "Seven sources"
version = "0.4.7"
checksum = "00"
sources = [
    { kpar_path = "example.kpar" },
    { src_path = "example/path" },
    { registry = "www.example.com" },
    { remote_kpar = "www.example.com/remote.kpar", remote_kpar_size = 64 },
    { remote_src = "www.example.com/remote" },
    { remote_git = "github.com/example/remote.git" },
    { remote_api = "www.example.com/api" },
]
"#,
        );
    }

    #[test]
    fn one_usage_to_toml() {
        test_to_toml(
            vec![Project {
                name: "One usage".to_string(),
                version: "0.5.1".to_string(),
                exports: vec![],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![Usage {
                    resource: "urn:kpar:usage".to_string(),
                    version_constraint: None,
                }],
            }],
            r#"
[[project]]
name = "One usage"
version = "0.5.1"
checksum = "00"
usages = [
    { resource = "urn:kpar:usage" },
]
"#,
        );
    }

    #[test]
    fn many_usage_to_toml() {
        test_to_toml(
            vec![Project {
                name: "Three usages".to_string(),
                version: "0.5.3".to_string(),
                exports: vec![],
                iris: vec![],
                checksum: "00".to_string(),
                specification: None,
                sources: vec![],
                usages: vec![
                    Usage {
                        resource: "urn:kpar:first".to_string(),
                        version_constraint: None,
                    },
                    Usage {
                        resource: "urn:kpar:second".to_string(),
                        version_constraint: Some("^2.0.0".to_string()),
                    },
                    Usage {
                        resource: "urn:kpar:third".to_string(),
                        version_constraint: Some(">=3.0.0".to_string()),
                    },
                ],
            }],
            r#"
[[project]]
name = "Three usages"
version = "0.5.3"
checksum = "00"
usages = [
    { resource = "urn:kpar:first" },
    { resource = "urn:kpar:second", version_constraint = "^2.0.0" },
    { resource = "urn:kpar:third", version_constraint = ">=3.0.0" },
]
"#,
        );
    }
}
