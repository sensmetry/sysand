// SPDX-FileCopyrightText: Â© 2025 Sysand contributors <opensource@sensmetry.com>
// SPDX-License-Identifier: MIT OR Apache-2.0

use std::{
    cmp::Ordering,
    collections::{HashMap, HashSet},
    fmt::Display,
    str::FromStr,
};

use semver::{Version, VersionReq};
use serde::Deserialize;
use thiserror::Error;
use toml_edit::{
    Array, ArrayOfTables, DocumentMut, Formatted, InlineTable, Item, Table, Value, value,
};

use crate::{env::ReadEnvironment, project::ProjectRead};

pub const LOCKFILE_PREFIX: &str = "# This file is automatically generated by Sysand and is not intended to be edited manually.\n\n";
pub const CURRENT_LOCK_VERSION: &str = "0.2";
pub const SUPPORTED_LOCK_VERSIONS: &[&str] = &[CURRENT_LOCK_VERSION];

pub const LOCKFILE_ENTRIES: &[&str] = &["lock_version", "project"];

#[derive(Clone, Debug, Deserialize, PartialEq)]
pub struct Lock {
    pub lock_version: String,
    #[serde(rename = "project", skip_serializing_if = "Vec::is_empty", default)]
    pub projects: Vec<Project>,
}

impl Default for Lock {
    fn default() -> Self {
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![],
        }
    }
}

#[derive(Debug, Error)]
pub enum ParseLockError {
    #[error(transparent)]
    Toml(#[from] toml::de::Error),
    #[error(transparent)]
    TomlEdit(#[from] toml_edit::TomlError),
    #[error(transparent)]
    Validation(#[from] ValidationError),
}

impl FromStr for Lock {
    type Err = ParseLockError;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let lock: Lock = toml::from_str(s)?;
        lock.validate()?;

        let document = DocumentMut::from_str(s)?;
        for (field, _) in document.iter() {
            if !LOCKFILE_ENTRIES.contains(&field) {
                log::warn!("unknown field '{}' in lockfile", field);
            }
        }
        for (field, value, name) in document
            .get("project")
            .and_then(Item::as_array_of_tables)
            .into_iter()
            .flat_map(|projects| projects.iter())
            .flat_map(|project| {
                project
                    .into_iter()
                    .map(|(field, value)| (field, value, project.get("name")))
            })
        {
            if !PROJECT_ENTRIES.contains(&field) {
                log::warn!(
                    "unknown field '{}' in {} in lockfile",
                    field,
                    project_with(name)
                );
            } else if field == "sources" {
                for (field, _) in value
                    .as_array()
                    .into_iter()
                    .flat_map(|sources| sources.iter())
                    .map(|source| source.as_inline_table())
                    .flat_map(|s| s.into_iter())
                    .flat_map(|s| s.into_iter())
                {
                    if !SOURCE_ENTRIES.contains(&field) {
                        log::warn!(
                            "unknown field '{}' in source for {} in lockfile",
                            field,
                            project_with(name)
                        );
                    }
                }
            }
        }

        Ok(lock)
    }
}

fn project_with<D: Display>(name: Option<D>) -> String {
    if let Some(name) = name {
        format!("project with name {}", name)
    } else {
        "project without name".to_string()
    }
}

impl Display for Lock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.to_toml())
    }
}

#[derive(Debug, Error)]
pub enum ResolutionError<EnvironmentError> {
    #[error(transparent)]
    CandidateProjects(EnvironmentError),
    #[error("missing projects: {0:?}")]
    MissingProjects(Vec<Project>),
}

#[derive(Debug, Error)]
pub enum ValidationError {
    #[error("lockfile version \"{0}\" is not supported")]
    UnsupportedVersion(String),
    #[error("\"{0}\" is exported by more than one project in lockfile")]
    NameCollision(String),
    #[error("unsatisfied usage '{usage}' for {project_with_name} in lockfile")]
    UnsatisfiedUsage {
        usage: String,
        project_with_name: String,
    },
    #[error(
        "unsatisfied usage '{usage}' for {project_with_name} (found version {version}) in lockfile"
    )]
    UnsatisfiedUsageVersion {
        usage: String,
        version: String,
        project_with_name: String,
    },
    #[error("invalid format of SHA256 checksum \"{checksum}\" for {project_with_name} in lockfile")]
    InvalidChecksumFormat {
        checksum: String,
        project_with_name: String,
    },
}

impl Lock {
    pub fn resolve_projects<Env: ReadEnvironment>(
        &self,
        env: &Env,
    ) -> Result<
        Vec<<Env as ReadEnvironment>::InterchangeProjectRead>,
        ResolutionError<Env::ReadError>,
    > {
        let mut missing = vec![];
        let mut found = vec![];

        for project in &self.projects {
            let checksum = &project.checksum;

            let mut resolved_project = None;

            'outer: for iri in &project.identifiers {
                for candidate_project in env
                    .candidate_projects(iri)
                    .map_err(ResolutionError::CandidateProjects)?
                {
                    if let Ok(Some(candidate_checksum)) = candidate_project.checksum_canonical_hex()
                    {
                        if candidate_checksum == *checksum {
                            resolved_project = Some(candidate_project);
                            break 'outer;
                        }
                    }
                }
            }

            if let Some(success) = resolved_project {
                found.push(success);
            } else {
                missing.push(project.clone());
            }
        }

        if !missing.is_empty() {
            return Err(ResolutionError::MissingProjects(missing));
        }

        Ok(found)
    }

    pub fn to_toml(&self) -> DocumentMut {
        let mut doc = DocumentMut::new();
        doc.decor_mut().set_prefix(LOCKFILE_PREFIX);
        doc.insert("lock_version", value(Value::from(&self.lock_version)));

        let mut projects = ArrayOfTables::new();
        for project in &self.projects {
            projects.push(project.to_toml());
        }
        doc.insert("project", Item::ArrayOfTables(projects));

        doc
    }

    pub fn validate(&self) -> Result<(), ValidationError> {
        self.validate_lock_version()?;
        self.check_name_collision()?;
        self.validate_usages()?;
        self.validate_checksum_format()?;
        Ok(())
    }

    fn validate_lock_version(&self) -> Result<(), ValidationError> {
        if SUPPORTED_LOCK_VERSIONS.contains(&self.lock_version.as_str()) {
            Ok(())
        } else {
            Err(ValidationError::UnsupportedVersion(
                self.lock_version.clone(),
            ))
        }
    }

    fn check_name_collision(&self) -> Result<(), ValidationError> {
        let mut seen = HashSet::new();
        for project in &self.projects {
            for name in &project.exports {
                if !seen.insert(name) {
                    return Err(ValidationError::NameCollision(name.clone()));
                }
            }
        }
        Ok(())
    }

    fn validate_usages(&self) -> Result<(), ValidationError> {
        let mut iri_versions = HashMap::new();
        for project in &self.projects {
            let version = Version::parse(&project.version)
                .inspect_err(|err| {
                    log::warn!(
                        "invalid semantic version '{}' for project '{:?}'\n{}",
                        project.version,
                        project.name,
                        err
                    );
                })
                .ok();
            for iri in &project.identifiers {
                iri_versions.insert(iri.clone(), version.clone());
            }
        }
        for project in &self.projects {
            for usage in &project.usages {
                let Some(version) = iri_versions.get(&usage.resource) else {
                    return Err(ValidationError::UnsatisfiedUsage {
                        usage: usage.to_toml().to_string(),
                        project_with_name: project_with(project.name.clone()),
                    });
                };
                if let Some(version_constraint_str) = &usage.version_constraint {
                    let version_constraint = VersionReq::parse(version_constraint_str)
                        .inspect_err(|err| {
                            log::warn!(
                                "invalid semantic version requirement for usage '{}'\n{}",
                                usage.to_toml(),
                                err
                            );
                        })
                        .ok();
                    if let (Some(version_constraint), Some(version)) = (version_constraint, version)
                    {
                        if !version_constraint.matches(version) {
                            return Err(ValidationError::UnsatisfiedUsageVersion {
                                usage: usage.to_toml().to_string(),
                                version: version.to_string(),
                                project_with_name: project_with(project.name.clone()),
                            });
                        }
                    }
                }
            }
        }
        Ok(())
    }

    fn validate_checksum_format(&self) -> Result<(), ValidationError> {
        let fail = self
            .projects
            .iter()
            .map(|p| (p.checksum.clone(), p.name.clone()))
            .find(|(cs, _)| cs.len() != 64 || !cs.chars().all(|c| c.is_ascii_hexdigit()));
        if let Some((checksum, name)) = fail {
            Err(ValidationError::InvalidChecksumFormat {
                checksum,
                project_with_name: project_with(name),
            })
        } else {
            Ok(())
        }
    }

    pub fn canonicalize(mut self) -> Self {
        self.sort();
        self.canonicalize_checksums();
        self
    }

    pub fn sort(&mut self) {
        for project in &mut self.projects {
            project.exports.sort();
            project.identifiers.sort();
            project.usages.sort();
            project.sources.sort();
        }
        self.projects.sort();
    }

    pub fn canonicalize_checksums(&mut self) {
        for project in &mut self.projects {
            project.checksum.make_ascii_lowercase();
        }
    }
}

pub const PROJECT_ENTRIES: &[&str] = &[
    "name",
    "version",
    "exports",
    "identifiers",
    "usages",
    "sources",
    "checksum",
];

#[derive(Clone, Eq, Debug, Deserialize, PartialEq)]
pub struct Project {
    pub name: Option<String>,
    pub version: String,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub exports: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub identifiers: Vec<String>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub usages: Vec<Usage>,
    #[serde(skip_serializing_if = "Vec::is_empty", default)]
    pub sources: Vec<Source>,
    pub checksum: String,
}

impl Ord for Project {
    fn cmp(&self, other: &Self) -> Ordering {
        self.name
            .cmp(&other.name)
            .then(self.exports.cmp(&other.exports))
            // Since valid lockfiles should never have overlap in exports
            // further sorting is only for debugging purposes.
            .then(self.identifiers.cmp(&other.identifiers))
            .then(self.version.cmp(&other.version))
    }
}

impl PartialOrd for Project {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Project {
    pub fn to_toml(&self) -> Table {
        let mut table = Table::new();
        if let Some(name) = &self.name {
            table.insert("name", value(name));
        }
        table.insert("version", value(&self.version));
        let exports = multiline_list(self.exports.iter().map(Value::from));
        if !exports.is_empty() {
            table.insert("exports", value(exports));
        }
        let identifiers = multiline_list(self.identifiers.iter().map(Value::from));
        if !identifiers.is_empty() {
            table.insert("identifiers", value(identifiers));
        }
        let usages = multiline_list(self.usages.iter().map(|u| u.to_toml()));
        if !usages.is_empty() {
            table.insert("usages", value(usages));
        }
        let sources = multiline_list(self.sources.iter().map(|s| s.to_toml()));
        if !sources.is_empty() {
            table.insert("sources", value(sources));
        }
        table.insert("checksum", value(&self.checksum));
        table
    }
}

const SOURCE_ENTRIES: &[&str] = &[
    "editable",
    "src_path",
    "kpar_path",
    "registry",
    "remote_src",
    "remote_kpar",
    "remote_kpar_size",
    "remote_git",
    "remote_api",
];

#[derive(Clone, Eq, Debug, Deserialize, Ord, PartialEq, PartialOrd)]
#[serde(untagged)]
pub enum Source {
    Editable {
        editable: String,
    },
    LocalSrc {
        src_path: String,
    },
    LocalKpar {
        kpar_path: String,
    },
    Registry {
        registry: String,
    },
    RemoteKpar {
        remote_kpar: String,
        remote_kpar_size: Option<u64>,
    },
    RemoteSrc {
        remote_src: String,
    },
    RemoteGit {
        remote_git: String,
    },
    RemoteApi {
        remote_api: String,
    },
}

impl Source {
    pub fn to_toml(&self) -> InlineTable {
        let mut table = InlineTable::new();
        match self {
            Source::Editable { editable } => {
                table.insert("editable", Value::from(editable));
            }
            Source::LocalKpar { kpar_path } => {
                table.insert("kpar_path", Value::from(kpar_path));
            }
            Source::LocalSrc { src_path } => {
                table.insert("src_path", Value::from(src_path));
            }
            Source::Registry { registry } => {
                table.insert("registry", Value::from(registry));
            }
            Source::RemoteApi { remote_api } => {
                table.insert("remote_api", Value::from(remote_api));
            }
            Source::RemoteGit { remote_git } => {
                table.insert("remote_git", Value::from(remote_git));
            }
            Source::RemoteKpar {
                remote_kpar,
                remote_kpar_size,
            } => {
                table.insert("remote_kpar", Value::from(remote_kpar));
                if let Some(remote_kpar_size) = remote_kpar_size {
                    let size = i64::try_from(*remote_kpar_size).unwrap();
                    table.insert("remote_kpar_size", Value::Integer(Formatted::new(size)));
                }
            }
            Source::RemoteSrc { remote_src } => {
                table.insert("remote_src", Value::from(remote_src));
            }
        }
        table
    }
}

#[derive(Clone, Eq, Debug, Deserialize, Ord, PartialEq, PartialOrd)]
pub struct Usage {
    pub resource: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_constraint: Option<String>,
}

impl Usage {
    pub fn to_toml(&self) -> InlineTable {
        let mut table = InlineTable::new();
        table.insert("resource", Value::from(&self.resource));
        if let Some(version_constraint) = &self.version_constraint {
            table.insert("version_constraint", Value::from(version_constraint));
        }
        table
    }
}

impl From<crate::model::InterchangeProjectUsageRaw> for Usage {
    fn from(value: crate::model::InterchangeProjectUsageRaw) -> Usage {
        Usage {
            resource: value.resource,
            version_constraint: value.version_constraint,
        }
    }
}

impl From<crate::model::InterchangeProjectUsage> for Usage {
    fn from(value: crate::model::InterchangeProjectUsage) -> Usage {
        Usage {
            resource: value.resource.to_string(),
            version_constraint: value.version_constraint.map(|vr| vr.to_string()),
        }
    }
}

fn multiline_list(elements: impl Iterator<Item = impl Into<Value>>) -> Array {
    let mut array: Array = elements
        .map(|item| {
            let mut value = item.into();
            value.decor_mut().set_prefix("\n    ");
            value
        })
        .collect();
    array.set_trailing_comma(true);
    array.set_trailing("\n");
    array
}

#[cfg(test)]
mod tests {
    use std::fmt::Display;

    use crate::lock::{
        CURRENT_LOCK_VERSION, LOCKFILE_PREFIX, Lock, Project, Source, Usage, ValidationError,
        project_with,
    };

    const CHECKSUM: &str = "0000000000000000000000000000000000000000000000000000000000000000";

    fn test_to_toml<D: Display>(projects: Vec<Project>, toml: D) {
        let lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects,
        };
        let expected = format!(
            "{}lock_version = \"{}\"\n{}",
            LOCKFILE_PREFIX, CURRENT_LOCK_VERSION, toml
        );
        assert_eq!(lock.to_string(), expected.to_string());
    }

    #[test]
    fn minimal_to_toml() {
        test_to_toml(
            vec![Project {
                name: None,
                version: "0.0.1".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
version = "0.0.1"
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn many_projects_to_toml() {
        test_to_toml(
            vec![
                Project {
                    name: Some("One".to_string()),
                    version: "0.0.1".to_string(),
                    exports: vec![],
                    identifiers: vec![],
                    usages: vec![],
                    sources: vec![],
                    checksum: CHECKSUM.to_string(),
                },
                Project {
                    name: Some("Two".to_string()),
                    version: "0.0.2".to_string(),
                    exports: vec![],
                    identifiers: vec![],
                    usages: vec![],
                    sources: vec![],
                    checksum: CHECKSUM.to_string(),
                },
                Project {
                    name: Some("Three".to_string()),
                    version: "0.0.3".to_string(),
                    exports: vec![],
                    identifiers: vec![],
                    usages: vec![],
                    sources: vec![],
                    checksum: CHECKSUM.to_string(),
                },
            ],
            format!(
                r#"
[[project]]
name = "One"
version = "0.0.1"
checksum = "{CHECKSUM}"

[[project]]
name = "Two"
version = "0.0.2"
checksum = "{CHECKSUM}"

[[project]]
name = "Three"
version = "0.0.3"
checksum = "{CHECKSUM}"
"#,
            ),
        );
    }

    #[test]
    fn one_export_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("One Package".to_string()),
                version: "0.1.1".to_string(),
                exports: vec!["PackageName".to_string()],
                identifiers: vec![],
                usages: vec![],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "One Package"
version = "0.1.1"
exports = [
    "PackageName",
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn many_exports_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("Three Packages".to_string()),
                version: "0.1.3".to_string(),
                exports: vec![
                    "Package1".to_string(),
                    "Package2".to_string(),
                    "Package3".to_string(),
                ],
                identifiers: vec![],
                usages: vec![],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "Three Packages"
version = "0.1.3"
exports = [
    "Package1",
    "Package2",
    "Package3",
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn one_iri_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("One IRI".to_string()),
                version: "0.2.1".to_string(),
                exports: vec![],
                identifiers: vec!["urn:kpar:example".to_string()],
                usages: vec![],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "One IRI"
version = "0.2.1"
identifiers = [
    "urn:kpar:example",
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn many_identifiers_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("Three IRI:s".to_string()),
                version: "0.2.3".to_string(),
                exports: vec![],
                identifiers: vec![
                    "urn:kpar:example".to_string(),
                    "ftp://www.example.com".to_string(),
                    "http://www.example.com".to_string(),
                ],
                usages: vec![],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "Three IRI:s"
version = "0.2.3"
identifiers = [
    "urn:kpar:example",
    "ftp://www.example.com",
    "http://www.example.com",
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn ome_source_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("One source".to_string()),
                version: "0.4.1".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![],
                sources: vec![Source::Editable {
                    editable: ".".to_string(),
                }],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "One source"
version = "0.4.1"
sources = [
    {{ editable = "." }},
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn many_sources_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("Seven sources".to_string()),
                version: "0.4.7".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![],
                sources: vec![
                    Source::LocalKpar {
                        kpar_path: "example.kpar".to_string(),
                    },
                    Source::LocalSrc {
                        src_path: "example/path".to_string(),
                    },
                    Source::Registry {
                        registry: "www.example.com".to_string(),
                    },
                    Source::RemoteKpar {
                        remote_kpar: "www.example.com/remote.kpar".to_string(),
                        remote_kpar_size: Some(64),
                    },
                    Source::RemoteSrc {
                        remote_src: "www.example.com/remote".to_string(),
                    },
                    Source::RemoteGit {
                        remote_git: "github.com/example/remote.git".to_string(),
                    },
                    Source::RemoteApi {
                        remote_api: "www.example.com/api".to_string(),
                    },
                ],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "Seven sources"
version = "0.4.7"
sources = [
    {{ kpar_path = "example.kpar" }},
    {{ src_path = "example/path" }},
    {{ registry = "www.example.com" }},
    {{ remote_kpar = "www.example.com/remote.kpar", remote_kpar_size = 64 }},
    {{ remote_src = "www.example.com/remote" }},
    {{ remote_git = "github.com/example/remote.git" }},
    {{ remote_api = "www.example.com/api" }},
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn one_usage_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("One usage".to_string()),
                version: "0.5.1".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![Usage {
                    resource: "urn:kpar:usage".to_string(),
                    version_constraint: None,
                }],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "One usage"
version = "0.5.1"
usages = [
    {{ resource = "urn:kpar:usage" }},
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    #[test]
    fn many_usage_to_toml() {
        test_to_toml(
            vec![Project {
                name: Some("Three usages".to_string()),
                version: "0.5.3".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![
                    Usage {
                        resource: "urn:kpar:first".to_string(),
                        version_constraint: None,
                    },
                    Usage {
                        resource: "urn:kpar:second".to_string(),
                        version_constraint: Some("^2.0.0".to_string()),
                    },
                    Usage {
                        resource: "urn:kpar:third".to_string(),
                        version_constraint: Some(">=3.0.0".to_string()),
                    },
                ],
                sources: vec![],
                checksum: CHECKSUM.to_string(),
            }],
            format!(
                r#"
[[project]]
name = "Three usages"
version = "0.5.3"
usages = [
    {{ resource = "urn:kpar:first" }},
    {{ resource = "urn:kpar:second", version_constraint = "^2.0.0" }},
    {{ resource = "urn:kpar:third", version_constraint = ">=3.0.0" }},
]
checksum = "{CHECKSUM}"
"#
            ),
        );
    }

    fn test_roundtrip<D: Display>(toml: D) {
        let expected = format!(
            "{}lock_version = \"{}\"\n{}",
            LOCKFILE_PREFIX, CURRENT_LOCK_VERSION, toml
        );
        let lockfile: Lock = toml::from_str(&expected).unwrap();
        assert_eq!(lockfile.to_string(), expected);
    }

    #[test]
    fn simple_roundtrip() {
        test_roundtrip(format!(
            r#"
[[project]]
name = "Simple"
version = "0.0.1"
checksum = "{CHECKSUM}"
"#
        ));
    }

    #[test]
    fn complex_roundtrip() {
        test_roundtrip(format!(
            r#"
[[project]]
name = "One"
version = "0.0.1"
exports = [
    "Package1",
    "Package2",
    "Package3",
]
usages = [
    {{ resource = "urn:kpar:usage" }},
]
checksum = "{CHECKSUM}"

[[project]]
name = "Two"
version = "0.0.2"
exports = [
    "PackageName",
]
identifiers = [
    "urn:kpar:example",
    "ftp://www.example.com",
    "http://www.example.com",
]
checksum = "{CHECKSUM}"

[[project]]
name = "Three"
version = "0.0.3"
identifiers = [
    "urn:kpar:example",
]
usages = [
    {{ resource = "urn:kpar:first" }},
    {{ resource = "urn:kpar:second", version_constraint = "^2.0.0" }},
    {{ resource = "urn:kpar:third", version_constraint = ">=3.0.0" }},
]
checksum = "{CHECKSUM}"
"#
        ));
    }

    fn make_project<S: AsRef<str>>(
        name: Option<String>,
        version: S,
        exports: &[&'static str],
        identifiers: &[&'static str],
        usages: &[Usage],
    ) -> Project {
        Project {
            name,
            version: version.as_ref().to_string(),
            exports: exports.iter().map(|s| String::from(*s)).collect(),
            identifiers: identifiers.iter().map(|s| String::from(*s)).collect(),
            usages: usages.to_vec(),
            sources: vec![],
            checksum: CHECKSUM.to_string(),
        }
    }

    #[test]
    fn validate_empty() {
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![],
        }
        .validate()
        .unwrap();
    }

    #[test]
    fn validate_minimal() {
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![make_project(None, "0.0.1", &[], &[], &[])],
        }
        .validate()
        .unwrap();
    }

    #[test]
    fn validate_single_usage() {
        let iri = "urn:kpar:test";
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![
                make_project(
                    None,
                    "0.0.1",
                    &[],
                    &[],
                    &[Usage {
                        resource: iri.to_string(),
                        version_constraint: None,
                    }],
                ),
                make_project(None, "0.0.1", &[], &[iri], &[]),
            ],
        }
        .validate()
        .unwrap();
    }

    #[test]
    fn validate_multiple_usage() {
        let iri1 = "urn:kpar:test1";
        let iri2 = "urn:kpar:test2";
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![
                make_project(
                    None,
                    "0.0.1",
                    &[],
                    &[],
                    &[
                        Usage {
                            resource: iri1.to_string(),
                            version_constraint: None,
                        },
                        Usage {
                            resource: iri2.to_string(),
                            version_constraint: None,
                        },
                    ],
                ),
                make_project(None, "0.0.1", &[], &[iri1], &[]),
                make_project(None, "0.0.1", &[], &[iri2], &[]),
            ],
        }
        .validate()
        .unwrap();
    }

    #[test]
    fn validate_chained_usages() {
        let iri1 = "urn:kpar:test1";
        let iri2 = "urn:kpar:test2";
        Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![
                make_project(
                    None,
                    "0.0.1",
                    &[],
                    &[],
                    &[Usage {
                        resource: iri1.to_string(),
                        version_constraint: None,
                    }],
                ),
                make_project(
                    None,
                    "0.0.1",
                    &[],
                    &[iri1],
                    &[Usage {
                        resource: iri2.to_string(),
                        version_constraint: None,
                    }],
                ),
                make_project(None, "0.0.1", &[], &[iri2], &[]),
            ],
        }
        .validate()
        .unwrap();
    }

    #[test]
    fn validate_unsupported_lock_version() {
        let version = "X".to_string();
        let Err(err) = Lock {
            lock_version: version.clone(),
            projects: vec![],
        }
        .validate() else {
            panic!()
        };
        let ValidationError::UnsupportedVersion(s) = err else {
            panic!()
        };
        assert_eq!(s, version);
    }

    #[test]
    fn validate_single_name_collision() {
        let name = "PackageName";
        let iri = "urn:kpar:test";
        let Err(err) = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![
                make_project(
                    None,
                    "0.0.1",
                    &[name],
                    &[],
                    &[Usage {
                        resource: iri.to_string(),
                        version_constraint: None,
                    }],
                ),
                make_project(None, "0.0.1", &[name], &[iri], &[]),
            ],
        }
        .validate() else {
            panic!()
        };
        let ValidationError::NameCollision(s) = err else {
            panic!()
        };
        assert_eq!(s, name);
    }

    #[test]
    fn validate_multiple_name_collision() {
        let name1 = "PackageName1";
        let name2 = "PackageName2";
        let name3 = "PackageName3";
        let name4 = "PackageName5";
        let iri = "urn:kpar:test";
        let Err(err) = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![
                make_project(
                    None,
                    "0.0.1",
                    &[name1, name2, name3],
                    &[],
                    &[Usage {
                        resource: iri.to_string(),
                        version_constraint: None,
                    }],
                ),
                make_project(None, "0.0.1", &[name2, name3, name4], &[iri], &[]),
            ],
        }
        .validate() else {
            panic!()
        };
        let ValidationError::NameCollision(_) = err else {
            panic!()
        };
    }

    #[test]
    fn validate_unsatisfied_usage() {
        let usage_in = Usage {
            resource: "urn:kpar:test".to_string(),
            version_constraint: None,
        };
        let Err(err) = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![make_project(None, "0.0.1", &[], &[], &[usage_in.clone()])],
        }
        .validate() else {
            panic!()
        };
        let ValidationError::UnsatisfiedUsage {
            usage,
            project_with_name,
        } = err
        else {
            panic!()
        };
        assert_eq!(usage, usage_in.to_toml().to_string());
        assert_eq!(project_with_name, project_with::<String>(None));
    }

    #[test]
    fn validate_unsatisfied_usage_version() {
        let iri = "urn:kpar:test";
        let version_in = "1.0.0";
        let usage_in = Usage {
            resource: iri.to_string(),
            version_constraint: Some("<1.0.0".to_string()),
        };
        let Err(err) = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![
                make_project(None, "0.0.1", &[], &[], &[usage_in.clone()]),
                make_project(None, version_in, &[], &[iri], &[]),
            ],
        }
        .validate() else {
            panic!()
        };
        let ValidationError::UnsatisfiedUsageVersion {
            usage,
            version,
            project_with_name,
        } = err
        else {
            panic!()
        };
        assert_eq!(usage, usage_in.to_toml().to_string());
        assert_eq!(version, version_in.to_string());
        assert_eq!(project_with_name, project_with::<String>(None));
    }

    #[test]
    fn validate_checksum() {
        let invalid_checksum =
            "dA8747a6f27A32f10Ba393113bCE29fX88181037a71f093f90e0ad5829D2b780".to_string();
        let Err(err) = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![Project {
                name: None,
                version: "0.0.1".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![],
                sources: vec![],
                checksum: invalid_checksum.clone(),
            }],
        }
        .validate() else {
            panic!()
        };
        let ValidationError::InvalidChecksumFormat {
            checksum,
            project_with_name,
        } = err
        else {
            panic!()
        };
        assert_eq!(checksum, invalid_checksum);
        assert_eq!(project_with_name, project_with::<String>(None));
    }

    #[test]
    fn sort_empty() {
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![]);
    }

    #[test]
    fn sort_single_trivial() {
        let project = make_project(None, "0.0.1", &[], &[], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project.clone()],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project]);
    }

    #[test]
    fn sort_exports() {
        let project1 = make_project(None, "0.0.1", &["B", "A"], &[], &[]);
        let project2 = make_project(None, "0.0.1", &["A", "B"], &[], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project1],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project2]);
    }

    #[test]
    fn sort_identifiers() {
        let project1 = make_project(None, "0.0.1", &[], &["urn:kpar:b", "urn:kpar:a"], &[]);
        let project2 = make_project(None, "0.0.1", &[], &["urn:kpar:a", "urn:kpar:b"], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project1],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project2]);
    }

    #[test]
    fn sort_sources() {
        let usage1 = Usage {
            resource: "urn:kpar:a".to_string(),
            version_constraint: None,
        };
        let usage2 = Usage {
            resource: "urn:kpar:b".to_string(),
            version_constraint: None,
        };
        let project1 = make_project(None, "0.0.1", &[], &[], &[usage2.clone(), usage1.clone()]);
        let project2 = make_project(None, "0.0.1", &[], &[], &[usage1, usage2]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project1],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project2]);
    }

    #[test]
    fn sort_sources_with_constraints() {
        let usage1 = Usage {
            resource: "urn:kpar:a".to_string(),
            version_constraint: Some("^1.0.0".to_string()),
        };
        let usage2 = Usage {
            resource: "urn:kpar:a".to_string(),
            version_constraint: Some("^1.0.0".to_string()),
        };
        let project1 = make_project(None, "0.0.1", &[], &[], &[usage2.clone(), usage1.clone()]);
        let project2 = make_project(None, "0.0.1", &[], &[], &[usage1, usage2]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project1],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project2]);
    }

    #[test]
    fn sort_projects_by_name() {
        let project1 = make_project(Some("A".to_string()), "0.0.2", &["B"], &["urn:kpar:b"], &[]);
        let project2 = make_project(Some("B".to_string()), "0.0.1", &["A"], &["urn:kpar:a"], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project2.clone(), project1.clone()],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project1, project2]);
    }

    #[test]
    fn sort_projects_by_exports() {
        let project1 = make_project(Some("A".to_string()), "0.0.2", &["A"], &["urn:kpar:b"], &[]);
        let project2 = make_project(Some("A".to_string()), "0.0.1", &["B"], &["urn:kpar:a"], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project2.clone(), project1.clone()],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project1, project2]);
    }

    #[test]
    fn sort_projects_by_identifiers() {
        let project1 = make_project(Some("A".to_string()), "0.0.2", &["A"], &["urn:kpar:a"], &[]);
        let project2 = make_project(Some("A".to_string()), "0.0.1", &["A"], &["urn:kpar:b"], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project2.clone(), project1.clone()],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project1, project2]);
    }

    #[test]
    fn sort_projects_by_version() {
        let project1 = make_project(Some("A".to_string()), "0.0.1", &["A"], &["urn:kpar:a"], &[]);
        let project2 = make_project(Some("A".to_string()), "0.0.2", &["A"], &["urn:kpar:a"], &[]);
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![project2.clone(), project1.clone()],
        };
        lock.sort();
        let Lock { projects, .. } = lock;
        assert_eq!(projects, vec![project1, project2]);
    }

    #[test]
    fn canonicalize_checksums() {
        let mut lock = Lock {
            lock_version: CURRENT_LOCK_VERSION.to_string(),
            projects: vec![Project {
                name: None,
                version: "0.0.1".to_string(),
                exports: vec![],
                identifiers: vec![],
                usages: vec![],
                sources: vec![],
                checksum: "dA8747a6f27A32f10Ba393113bCE29f788181037a71f093f90e0ad5829D2b780"
                    .to_string(),
            }],
        };
        lock.canonicalize_checksums();
        let Lock { projects, .. } = lock;
        let [project] = projects.as_slice() else {
            panic!()
        };
        assert_eq!(
            project.checksum,
            "da8747a6f27a32f10ba393113bce29f788181037a71f093f90e0ad5829d2b780".to_string()
        );
    }
}
